"""
Market Data Loading Module

This module provides functions to load and process market data from CSV files
generated by the baseoffset fitting process.
"""

import polars as pl
from datetime import datetime
from typing import List


def load_baseoffset_results(date_str: str, results_path: str = "../results") -> pl.DataFrame:
    """
    Load baseoffset results from CSV file.
    
    Args:
        date_str: Date string in format 'YYYYMMDD'
        results_path: Path to the results directory
        
    Returns:
        DataFrame with baseoffset results including timestamp, F, r columns
    """
    file_path = f'{results_path}/{date_str}/baseoffset_results.csv'
    
    return pl.read_csv(file_path).with_columns(
        timestamp=pl.col('timestamp').cast(pl.Datetime('ns'))
    )


def load_option_market_data(date_str: str, results_path: str = "../results") -> pl.DataFrame:
    """
    Load option market data from CSV file.
    
    Args:
        date_str: Date string in format 'YYYYMMDD'
        results_path: Path to the results directory
        
    Returns:
        DataFrame with option market data including bid/ask prices, strikes, expiries
    """
    file_path = f'{results_path}/{date_str}/conflated_md.csv'
    
    df = pl.read_csv(file_path).with_columns(
        timestamp=pl.col('timestamp').cast(pl.Datetime('ns')),
        expiry_ts=pl.col('expiry_ts').cast(pl.Datetime('ns'))
    ).select([
        'symbol', 'timestamp', 'expiry', 'strike', 'bid_size', 'bid_price', 
        'ask_price', 'ask_size', 'S', 'expiry_ts', 'is_option', 'is_call', 'tau'
    ]).sort(['timestamp', 'expiry_ts'])
    
    print(f"Available expiries: {df['expiry'].unique().to_list()}")
    return df


def create_snapshot_option_chain(
    option_md_df: pl.DataFrame, 
    baseoffset_df: pl.DataFrame, 
    snapshot_time: datetime
) -> pl.DataFrame:
    """
    Create option chain snapshot at specific timestamp by joining market data with baseoffset results.
    
    Args:
        option_md_df: Option market data DataFrame
        baseoffset_df: Baseoffset results DataFrame  
        snapshot_time: Timestamp for the snapshot
        
    Returns:
        DataFrame with option chain data at specified timestamp
        
    Raises:
        AssertionError: If snapshot_time not found in data or spot price not unique
    """
    # Validate timestamp exists in both datasets
    if snapshot_time not in option_md_df['timestamp'].unique().to_list():
        raise ValueError(f"Snapshot time {snapshot_time} not found in option market data")
    if snapshot_time not in baseoffset_df['timestamp'].unique().to_list():
        raise ValueError(f"Snapshot time {snapshot_time} not found in baseoffset data")
    
    # Filter and prepare option market data
    df = option_md_df.filter(pl.col('timestamp') == snapshot_time).with_columns(
        option_type=pl.when(pl.col('is_call')).then(pl.lit('C')).otherwise(pl.lit('P'))
    ).select([
        'symbol', 'timestamp', 'expiry', 'strike', 'bid_size', 'bid_price', 
        'ask_price', 'ask_size', 'S', 'expiry_ts', 'option_type', 'tau'
    ])
    
    # Join with baseoffset data
    df = df.join(
        baseoffset_df.filter(pl.col('timestamp') == snapshot_time).select([
            'expiry', 'timestamp', 'F', 'r'
        ]),
        on=['timestamp', 'expiry']
    ).sort(['expiry_ts', 'strike', 'option_type'])

    # Validate spot price consistency
    unique_spots = df['S'].unique()
    if len(unique_spots) != 1:
        raise ValueError(f"Spot price should be unique across all options. Found: {unique_spots.to_list()}")

    return df


def get_available_expiries(option_md_df: pl.DataFrame, snapshot_time: datetime) -> List[str]:
    """
    Get list of available expiries for a given snapshot time.
    
    Args:
        option_md_df: Option market data DataFrame
        snapshot_time: Timestamp to check
        
    Returns:
        List of available expiry strings
    """
    return (option_md_df
            .filter(pl.col('timestamp') == snapshot_time)['expiry']
            .unique()
            .to_list())


def validate_snapshot_data(df: pl.DataFrame) -> dict:
    """
    Validate snapshot option chain data and return summary statistics.
    
    Args:
        df: Option chain DataFrame
        
    Returns:
        Dictionary with validation results and summary statistics
    """
    summary = {
        'total_options': len(df),
        'unique_strikes': df['strike'].n_unique(),
        'unique_expiries': df['expiry'].n_unique(),
        'calls_count': len(df.filter(pl.col('option_type') == 'C')),
        'puts_count': len(df.filter(pl.col('option_type') == 'P')),
        'spot_price': df['S'][0] if len(df) > 0 else None,
        'forward_prices': df['F'].unique().to_list(),
        'time_to_expiries': df['tau'].unique().to_list(),
        'strike_range': (df['strike'].min(), df['strike'].max()) if len(df) > 0 else (None, None)
    }
    
    # Validation checks
    summary['is_valid'] = (
        summary['total_options'] > 0 and
        summary['calls_count'] > 0 and 
        summary['puts_count'] > 0 and
        summary['spot_price'] is not None
    )
    
    return summary